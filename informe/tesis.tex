\documentclass{llncs}
\bibliographystyle{splncs}
\renewcommand{\contentsname}{\'Indice general}
\renewcommand\refname{Bibliograf\'ia}
\renewcommand\abstractname{Resumen}
\usepackage{listings}
\usepackage{indentfirst, enumitem,amsmath}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[usenames, dvipsnames]{color}
\usepackage{comment}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\makeatletter
\newenvironment{breakablealgorithm}
{% \begin{breakablealgorithm}
	\begin{center}
		\refstepcounter{algorithm}% New algorithm
		\hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
		\renewcommand{\caption}[2][\relax]{% Make a new \caption
			{\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
			\ifx\relax##1\relax % #1 is \relax
			\addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
			\else % #1 is not \relax
			\addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
			\fi
			\kern2pt\hrule\kern2pt
		}
	}{% \end{breakablealgorithm}
		\kern2pt\hrule\relax% \@fs@post for \@fs@ruled
	\end{center}
}
\makeatother


% Titulo
\title{Selecci\'on de Componentes Discretos para un Filtro Activo Mediante
  \textit{Constraint Programming}} 
\author{Leandro Demarco Vedelago}
\institute{
            \email{leandrodemarco@gmail.com}\\
            Universidad Nacional de C\'ordoba, Fa.M.A.F
          }
\setcounter{tocdepth}{3}
\begin{document}
{\def\addcontentsline#1#2#3{}\maketitle
  \noindent
  \makebox[\linewidth]{\small 25 de Marzo de 2017}}
  
\begin{abstract}
  Esto es el resumen 
\end{abstract}
% Fin titulo

%Tabla de contenidos
\tableofcontents
\newpage
%Fin tabla de contenidos
  \section{\textbf{Motivaci\'on}}
    \label{sec:motivacion}
    El dise\~no electr\'onico actual incluye a los filtros activos en muchas aplicaciones,
    tales como acondicionamiento y manipulaci\'on de se\~nales en frecuencias de audio e
    intermedias (IF) as\'i como tareas de procesamiento digital de se\~nales. En
    contraposici\'on a los filtros digitales, los activos pueden obtener buena performance
    con demandas de potencia significativamente menores.
    
    Las alternativas de implementaci\'on de filtros activos presentan muchas opciones.
    Entre \'estas, las implementaciones RC (resistencia/capacitor), construidas a partir de
    amplificadores operacionales, resistencias y capacitores son una de las m\'as utilizadas
    por los ingenieros.\cite{corr}
    
  \section{\textbf{Fundamentos electr\'onicos}}
    \label{sec:fundelect}
    
  \section{\textbf{Fundamentos de \textit{Constraint Programming}}}
    \label{sec:fundprog}
    Intuitivamente, los problemas de satisfacci\'on de restricciones pueden definirse como \textit{encontrar
    una soluci\'on que satisface determinadas restricciones o pro\-pie\-da\-des}.
    Por ejemplo, el planeamiento y control del tr\'afico a\'ereo en un aeropuerto, el empacar cajas dentro de un
    espacio dado o el confeccionamiento de una agenda de clases. 
    Todos estos problemas suelen ser \textit{NP}-Complejos.
    
    \subsection{Noci\'on de una restricci\'on}
      Una restricci\'on puede pensarse como una relaci\'on l\'ogica entre un conjunto de valores, en principio,
      desconocidos, tambi\'en llamados \textit{variables}. De esta forma, una restricci\'on restringe el conjunto
      de valores que pueden asignarse simultaneamente a sus variables.
      
      Una posibilidad para definirla consiste en enumerar todo el conjunto de tuplas que pertenece a la relaci\'on o,
      dualmente, especificar aquellos que \textbf{no} pertenecen a ella.
      
      Existen diferentes tipos de restricciones, de acuerdo a los valores que pueden asignarse a las variables. As\'i,
      tenemos restricciones num\'ericas, booleanas, sobre conjuntos, etc. Una restricci\'on num\'erica puede ser entonces
      una igualdad ($=$) o bien una desigualdad ($\neq, \geq, \leq, <, >$) entre dos expresiones aritm\'eticas.
      
      Similarmente, las restricciones sobre conjuntos expresan relaciones entre variables cuyo rango son conjuntos y pueden
      incluir relaciones de igualdad ($=$), desigualdad ($\neq$), inclusi\'on ($\subset, \subseteq$) o pertenencia ($\in$).
      
    \subsection{Definici\'on de un problema de satisfacci\'on de restricciones}
      Podemos dar una definici\'on formal de un \textbf{CSP} (por las siglas en ingl\'es de \textit{Constraint
      Satisfaction Problem}) como sigue:
      
      Un CSP es una 3-upla (\textit{X}, \textit{D}, \textit{C}) tal que:
      \begin{itemize}
        \item \textit{X} es un conjunto finito de variables que corresponde a las inc\'ognitas del problema.
        \item \textit{D} es una funci\'on que asocia un dominio \textit{D}($x_i$) con cada variable $x_i \in \textit{X}$, es
        decir \textit{D}($x_i$) es el conjunto de valores que la variable $x_i$ puede tomar.
        \item \textit{C} es un conjunto finito de restricciones y cada restricci\'on $c_j \in C$ es una relaci\'on entre
        algunas variables de \textit{X}; este conjunto se denota como $var(c_j).$
      \end{itemize}
      
    
  \section{\textbf{Definici\'on del problema}}
    \label{sec:problemdefinition}
    El presente trabajo se basa en el desarrollado en \cite{lov:rom:per}. En el mismo, los autores
    utilizan algoritmos gen\'eticos para seleccionar los componentes discretos en un filtro activo $RC$. Como se
    estableci\'o en la secci\'on \ref{sec:fundelect}, el problema consiste en seleccionar los valores que pueden
    tomar las tres resistencias ($R_1$, $R_2$, $R_3$) y los dos capacitores ($C_4$, $C_5$) de una lista de posibles valores
    previamente definidos.
    
	El problema puede definirse entonces como un CSP de la siguiente forma:
	\begin{itemize}
		\item El conjunto de variables $X = \{R_1, R_2, R_3, C_4, C_5\}$
		\item La funci\'on $D$ donde $D(R_i) = E24  E96, i \in \{1,2,3\}$ y $D(C_i = E12 E24), i \in \{1,2\}$
		\item El conjunto de restricciones $C = \{G^{max} > G > G^{min}, \omega_p^{max} > \omega_p > \omega_p^{min},
		 Q^{max} > Q > Q^{min}\}$
	\end{itemize}

  \section{\textbf{Algoritmo exhaustivo}}
    Realizando algunas observaciones y transformaciones matem\'aticas, es posible obtener un algoritmo exhaustivo que descubre
    todas las soluciones posibles para el problema. Recordemos las definiciones
    de \textit{ganancia} ($G$), \textit{frecuencia de polo} ($\omega_p$) y
    \textit{factor de calidad} ($Q_p$)
    \begin{eqnarray}
      G &=& R_2/R_1 \label{g}\\
      \omega_p &=& 1/\sqrt{R_2 R_3 C_4 C_5} \label{omega}\\
      Q^{-1}_p &=& \sqrt{C_5/C_4}  \left(\sqrt{R_2 R_3}/R_1 + \sqrt{R_3/R_2} +
      \sqrt{R_2/R_3}\right) \label{q}
    \end{eqnarray}

    Es claro que a partir de (\ref{g}) se tiene que para cada valor de $R_1$ hay
    un conjunto de valores de $R_2$ que denotaremos 
    $\{R_2\}_{R_1}$ tales que $G^{max} > G > G^{min}$

    Definiendo las siguientes cantidades,
    \begin{eqnarray}
      \omega_1 &=& 1/(R_2 C_4) \nonumber \\
      \omega_2 &=& 1/(R_3 C_5)
      \label{omegas}
    \end{eqnarray}
    podemos reescribir (\ref{omega}) de la siguiente forma: $\omega_p = \sqrt{\omega_1  \omega_2}$

    
    A partir de los valores que pueden tomar las resistencias y capacitores, es
    posible calcular la lista de valores que pueden tomar las frecuencias
    definidas en (\ref{omegas}). Para cada uno de los valores posibles para
    $\omega_1$, habr\'a un conjunto de pares de valores ($R_2$, $C_4$) tales que
    $\omega_1 = 1/(R_2 C_4)$. Denotamos a tal conjunto como $\{(R_2,
      C_4)\}_{\omega_1}$. De manera an\'aloga se puede proceder con $\omega_2$,
      $R_3$ y $C_5$ (obs\'ervese el conjunto de valores posibles para $\omega_2$
      es el mismo que para $\omega_1$ y que $\{(R_2,C_4)\}_{\omega_1}=\{(R_3,
      C_5)\}_{\omega_2}$ cuando $\omega_1=\omega_2$). Luego, dada la restricci\'on $\omega_p \in 
    [\omega_p^{min},\omega_p^{max}]$ y elegido un valor de  $\omega_1$, los
    valores admisibles de $\omega_2$ son aquellos para los 
    que $\omega_p= \sqrt{\omega_1 \omega_2}$ satisface dicha restricci\'on, y
    por lo tanto cumplen las siguiente relaci\'on:
    $(\omega_p^{max})^2 / \omega_1 > \omega_2 > (\omega_p^{min})^2 / \omega_1 $.

    De esta manera, para cada valor realizable de $\omega_1$ existe un conjunto
    finito $\{{\omega_2}\}_{\omega_1}$ de valores de $\omega_2$ 
    tales que $ \omega_p^{max} > \omega_p > \omega_p^{min} $

    Finalmente, a partir de (\ref{q}) y (\ref{omegas}) podemos reescribir
    $Q_p^{-1}$ de la siguiente forma,
    \begin{equation}
    Q_p^{-1} =
    \sqrt{\frac{\omega_1}{\omega_2}}\left(1+\frac{R_2}{R_1}+\frac{R_2}{R_3}\right)
    \label{otraq}
    \end{equation}
    
    Finalmente, para cada par ($R_1$, $R_2$), ($\omega_1, \omega_2$) que satisface
    las restricciones sobre $G$ y $\omega_p$, utilizando la expresión
    (\ref{otraq}) buscamos
    los valores $R_3$ admisibles que satisfagan la 
    condici\'on
    $$
    (Q_p^{-1})^{max} > Q_p^{-1} > (Q_p^{-1})^{min}
    $$
    y de esta manera obtenemos todas las soluciones de la forma ($R_1$, $R_2$,
    $\omega_1$, $\omega_2$, $R_3$)  
    que luego podemos \textit{mapear} a las soluciones de la forma ($R_1$,
    $R_2$, $R_3$, $C_4$, $C_5$). 

	\begin{breakablealgorithm}
		\caption{Búsqueda exhaustiva}
		\label{alg:exhaustSearch}
%	\captionof{algorithm}{test caption}
		\begin{algorithmic}[1]
			\State $R_{vals}$: conjunto de valores que pueden tomar las resistencias
			\State $C_{vals}$: conjunto de valores que pueden tomar los capacitores
			\State $G^{min}$: valor mínimo aceptable para la ganancia
			\State $G^{max}$: valor máximo aceptable para la ganancia
			\State $\omega_p^{min}$: valor mínimo aceptable para la frecuencia de polo
			\State $\omega_p^{max}$: valor máximo aceptable para la frecuencia de polo
			\State $Q^{min}$: valor mínimo aceptable para el factor de calidad
			\State $Q^{max}$: valor máximo aceptable para el factor de calidad
			\item[]
			\Procedure{ExhaustiveSearch}{$R_{vals}$, $C_{vals}$}
			\State $soluciones \gets []$
			\State $G_{constraint} \gets  []$ \Comment{Obtener pares $(r1,r2)$ que satisfagan la restricción sobre G}
			\For{cada $r1$ en $R_{vals}$, cada $r2$ en $C_{vals}$}
			\State $G \gets r2/r1$
			\If{$G^{max} > G > G^{min}$}
			\State Agregar el par $(r1, r2)$ a $G_{constraint}$
			\EndIf 
			\EndFor
			\item[]
			\State $\omega_{constraint} \gets \{\}$ \Comment{Diccionario que para cada $\omega_1$ contiene el conjunto de los $\omega_2$ posibles para no violar la
			restricción}
			\State $wToRCMap \gets \{\}$  \Comment{Diccionario que para cada valor de $w$ contiene una lista con los pares $(r,c)$ que lo generan}
			\item[]
			\State $w_{vals} = [ ]$
			\For{cada $r$ en $R_{vals}$, cada $c$ en $C_{vals}$}
			\State $w \gets 1/(r*c)$
			\State Agregar el par $(r,c)$ a $wToRCMap[w]$
			\State Agregar $w$ a la lista $w_{vals}$
			\EndFor
			\For{cada $w_1$ en $w_{vals}$}
			\State $Posibles\_\omega_2 \gets [ ]$
			\For{cada $w_2$ en $w_{vals}$}
			\State $minVal \gets {(\omega_p^{min})}^{2}$
			\State $maxVal \gets {(\omega_p^{max})}^{2}$
			\If{$maxVal > w2 > minVal$}
			\State Agregar $w2$ a la lista $Posibles\_\omega_2$
			\EndIf
			\EndFor
			\If{$Posibles\_\omega_2$ no es vacía}
			\State Agregar $Posibles\_\omega_2$ a $\omega_{constraint}[\omega_1]$
			\EndIf
			\EndFor
			\item[]
			\For{cada par $(r1,r2)$ en $G_{constraint}$}
			\For{cada $\omega_1$ en las keys de $\omega_{constraint}$}
			\State $Posibles\_\omega_2 \gets \omega_{constraint}[\omega_1]$
			\State $genera \gets \exists (r,c) \in wToRCMap[\omega_1] \mid r = r_2$ \Comment{Chequear si $r_2$ \textit{genera} $\omega_1$}
			\If{$genera$}
			\For{cada $\omega_2$ en $Posibles\_\omega_2$, cada $r_3$ en $R_{vals}$}
			\State $genera \gets \exists (r,c) \in wToRCMap[\omega_2] \mid r = r_3$ \Comment{Chequear si $r_3$ \textit{genera} $\omega_2$}
			\If{$genera$}
			\State $(Q^{-1})_{r_3} \gets \sqrt{\omega_1 / \omega_2} * (1  + r_2/r_1 + r_2/r_3)$
			\If{$(Q^{min})^{-1} > (Q^{-1})_{r_3} > (Q^{max})^{-1}$}
			\State $c_4 \gets 1/(r_2 * \omega_1)$
			\State $c_5 \gets 1/(r_3 * \omega_2)$ 
			\State Agregar la tupla $(r_1, r_2, r3, c4, c5)$ a la lista $soluciones$
			\EndIf
			\EndIf
			\EndFor
			\EndIf
			\EndFor
			\EndFor
			\State \textbf{return} $soluciones$
			\EndProcedure
		\end{algorithmic}
	\end{breakablealgorithm}

  \section{\textbf{La Metaheurística ACO}}
  
  \section{\textbf{El Enfoque Continuo con ACO-$\mathbb{R} $}}

  \begin{thebibliography}{1}
      \bibitem{corr}
      Corral, C.: 
      Designing RC active filters with standard-component values. Electronic Design
      Network Magazine, 141-154 (2000)
      
      \bibitem{lov:rom:per}
      Lovay, M., Romero, E., Peretti, M.:
      Dise\~no de Filtros Activos Robustos usando Algoritmos Gen\'eticos.
      SII 2015 4$^\circ$ Simposio Argentino de Inform\'atica Industrial.
      
      \bibitem{sol}
      Solnon, C.:
      Ant Colony Optimization and Constraint Programming. (Wiley-ISTE 2010) 
      
      \bibitem{soc:dor}
      Socha, K., Dorigo, M.:
      Ant colony optimization for continuous domains.
      European Journal of Operational Research 185 (2008)
      
  \end{thebibliography}

\end{document}
